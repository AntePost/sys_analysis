# Как были выбраны контексты:
1. Есть 3 простых контекста связанных с пользователями: `clients`, `workers`, `managers`.

Их задача - предоставлять CRUD интерфейс, регистрировать новых клиентов и воркеров, и стримить данные в другие контексты

2. Рядом с `workers` есть `applicants`, где инкапсулирована логика с тестированием котов, которые хотят стать воркерами

Он также должен быть отдельным, так как у него есть опасность атаки DDoS

3. Контекст `orders` самый большой, там логика принятия заказа и его завершения

4. К нему примыкает контекст `order package preparing`, связанный со сборкой заказа после его принятия.

Он выделен отдельно, так как связан с физическими действиями по сборке заказа (видимо на отдельном складе).

Дальнейшая связь с заказом происходит в реальном мире (воркер забирает расходники и едет выполнять заказ)

5. Контекст `bets` примыкает к `orders`, но не нужен для его функционирования
6. Контекст `quality control` зависит от `orders`, но также некритичен для основного флоу работы с заказами

7. Контексты биллинга были разделены на 2: `worker billing` и `client billing`.

Они были разделены на 2, так как у них несвязанный флоу и они решают 2 разные задачи

# Почему была выбрана такая структура проекта

Была выбрана смешанная, но в основном микросервисная структура проекта:
1. Основной стриминг данных идет со стороны простых контекстов (`clients`, `workers`, `managers`)
2. Число бизнес событий невелико: `order accepted`, `applicant accepted`, `order finished`.

При этом `order finished` нужен для контекста `bets` и поэтому некритичен.

3. Итого, из-за небольшого числа связей между контекстами (в основном простой стриминг данных) был выбран микросервисный подход

4. В тоже время некоторые сервисы имеют общую БД:
  1. БД для `clients`, `orders`, `workers` находятся в рамках одной DBSM и сервис `orders` имеет read-only доступ к БД `clients` и `workers`
  2. Это сделано так как мы считаем надежность БД выше надежности нашего кода. Активной работы с `clients` и `workers` не ведет никто кроме сервиса `orders`
  3. В тоже время `orders` - это основной флоу компании, где нужно максимизировать SLA (в отличие от, например, биллинга, который запускает раз в неделю/месяц. Возникшие там проблемы со стримингом обычно нужно решать не в моменте). Поэтому было выбран вариант с шарингом БД между сервисами
  4. В результате единственная асинхронная зависимость `orders` - это `managers` стриминг, который некритичен для основного функционала и происходит редко

5. Для защиты `applicants` от DDoS была выбрана одна из сторонних систем, предоставляющих такую защиту (e.g. Cloudflare).

Ее действий распространяется только на фронтенд, связанный с `applicants`

# Какие были выбраны коммуникации

Между сервисами были выбраны асинхронные коммуникации, так как их в целом немного и они не нужны в формате real-time.

За исключением `order`, где нужна максимальная надежность и минимальная задержка (см. пункт 4 в предыдущем блоке)

# Какие были выбраны технологии

Пока не стал выбирать конкретный стэк (язык, БД, message broker), так как недостаточно данных для корректного выбора

# Потенциальные проблемы

1. Не уверен в правильности решения с шарингом базы (см. пункт 4 в блоке структуры проекта)
2. Ряд потенциальных проблем отражен на ES схеме и модели данных в виде комментариев
